{"_id":"splaytree-ts","_rev":"4-dfd1ad136432aedb7fa7cadb4466d987","name":"splaytree-ts","dist-tags":{"latest":"1.0.2"},"versions":{"1.0.0":{"name":"splaytree-ts","version":"1.0.0","keywords":["splay","tree","map","set","self-balancing","binary","search"],"author":{"name":"Luiz Felipe Machado Barboza"},"license":"BDS-3-Clause","_id":"splaytree-ts@1.0.0","maintainers":[{"name":"sbanksx","email":"luiz.barboza2002@gmail.com"}],"homepage":"https://github.com/SBanksX/splaytree-ts#readme","bugs":{"url":"https://github.com/SBanksX/splaytree-ts/issues"},"dist":{"shasum":"4f8cf6b0d639c1ea8072f239dbd8248aa36a301e","tarball":"https://registry.npmjs.org/splaytree-ts/-/splaytree-ts-1.0.0.tgz","fileCount":8,"integrity":"sha512-07VIexn/JyL8uk03cLdChy4KsTH/x5HakuI48YihGMx+7nGw6M2VA1oGX2qCi7ObqH8VnoDFh187GiA1aMJEjg==","signatures":[{"sig":"MEUCIACk+LJZ+6fgHZxNnNdL1xcDftLKX8hs6tizFusvdn7HAiEAk+kRBl9oloQCgk+E/N+IXbR9NlqxTthxrnwnyEPVJuY=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":98416,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjRyaCACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmrp8A//ZnV7LjNQWV+Q4DKH6S+OTZmWUzxNCCt4aUdZOpZNEtKETugj\r\nkecacOu54YDNryZPNy+azwzhDhUY7CUtTCBbq4keCRPl7PjIn1qV56ptB245\r\njnNXNXuCP5QMmTUo5TJWvnTJFZEfHmhc6fN+GcZnNOclYexJmjhL6afy2Vkd\r\nsx7qy4acxzEEG3UJF4fucTOLAuiFNDqN/7GjeiD8nenDfb0ZbX381mqGNjFS\r\na1VCG0sOEbIn9YT8ykyLZkLOz/7x2g9CHBieEWiMvbtJVEX9XDtbBuh3Qsj+\r\n5knhtvT/UnY+ZklaJSogGIKSQJkypCiydBGU1bRMdrGPRBgIkBv4oeo4Fy5C\r\nRvKwib64Plx3mQsP8fNHNyb5SFW6TA0c2CYBNe9l+j7FsNf0DiDd3XLWZweU\r\nwR4RFZpiotL84oVEcCd8VAgFK7j5oofr8/ZKyVBeN/GXQ7yjPFrDVb3ve40A\r\nVtIFk5bYEY3lIC/ypgQJ8cLNTbnBXoUSjfqr8Vov0IZl7sglixe15ATMutHr\r\ntcWOtHcHpKOCQQeIuSjofswknHX29tnsvTJGc/5tSz06VP+clabRKLEjpZmJ\r\nnFEIMuHJRmoUctv+MIIItzPZDYduxByShbFY4K76l0QOWyNfgYgxqfBZjN7z\r\nCHKTx6fooaYTKhwhM9+HZ2QXdp7ZGFur7es=\r\n=6bAT\r\n-----END PGP SIGNATURE-----\r\n"},"main":"dist/index.js","type":"module","types":"types/index.d.ts","unpkg":"dist/splaytree-ts.umd.js","module":"dist/index.js","exports":{"umd":"./dist/splaytree-ts.umd.js","default":"./dist/index.js"},"gitHead":"76eb662231bb211ee70204976a64aa6030227711","scripts":{"test":"npm run test:typecheck && npm run test:lint","build":"rollup -c && tsc --declaration true --declarationDir types","test:lint":"eslint src","prepublishOnly":"npm run test && npm run build","test:typecheck":"tsc --noEmit"},"_npmUser":{"name":"sbanksx","email":"luiz.barboza2002@gmail.com"},"jsdelivr":"dist/splaytree-ts.umd.js","repository":{"url":"git+https://github.com/SBanksX/splaytree-ts.git","type":"git"},"_npmVersion":"8.15.0","description":"A splay tree typescript library","directories":{},"_nodeVersion":"18.7.0","_hasShrinkwrap":false,"devDependencies":{"eslint":"^8.16.0","@babel/preset-env":"^7.19.0","@rollup/plugin-json":"4","rollup-plugin-terser":"7","eslint-config-prettier":"^8.5.0","@babel/preset-typescript":"^7.18.6","@rollup/plugin-typescript":"^8.5.0","@typescript-eslint/parser":"^5.25.0","@rollup/plugin-node-resolve":"13","@typescript-eslint/eslint-plugin":"^5.25.0"},"_npmOperationalInternal":{"tmp":"tmp/splaytree-ts_1.0.0_1665607297879_0.3510252858027101","host":"s3://npm-registry-packages"}},"1.0.1":{"name":"splaytree-ts","version":"1.0.1","keywords":["splay","tree","map","set","self-balancing","binary","search"],"author":{"name":"Luiz Felipe Machado Barboza"},"license":"BDS-3-Clause","_id":"splaytree-ts@1.0.1","maintainers":[{"name":"sbanksx","email":"luiz.barboza2002@gmail.com"}],"homepage":"https://github.com/SBanksX/splaytree-ts#readme","bugs":{"url":"https://github.com/SBanksX/splaytree-ts/issues"},"dist":{"shasum":"4ddcfe2684da017d02b599d53d67f6d07a90745b","tarball":"https://registry.npmjs.org/splaytree-ts/-/splaytree-ts-1.0.1.tgz","fileCount":8,"integrity":"sha512-B+VzCm33/KEchi/fzT6/3NRHm8k5+Kf37SBQO3meHHS/tK2xBnIm4ZvusQ1wUpHgKMCCqEWgXnwFXAa1nD289g==","signatures":[{"sig":"MEUCIQCp+qlwRLHm4bdwoiPSB7SpLqedBbjqKQPbqmpRDeb3XQIgGGHZ8YUJp5ZBZDArMrAqfkNk8vE5wwhuAHif3SNJkFg=","keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA"}],"unpackedSize":98408,"npm-signature":"-----BEGIN PGP SIGNATURE-----\r\nVersion: OpenPGP.js v4.10.10\r\nComment: https://openpgpjs.org\r\n\r\nwsFzBAEBCAAGBQJjSHMjACEJED1NWxICdlZqFiEECWMYAoorWMhJKdjhPU1b\r\nEgJ2Vmo1+RAAh7gCORJpwR06KrYtJu1fKF8LkEkFo/1+XZsf2syVEb1+AvGq\r\n2CqNpx3kY/UtsdjnE2X32GThUMhvuz+Xs6B7om1dBXkB001hoX7wWX/v7z0d\r\neNfzbJQ+S0v+7+4VrGDswGnEauuuB69biT/tfpZYU0RXVIAzmHeDh5BbkFrh\r\n1Xxa237Hm7vmA7m5pos8+UJPEKZCSysgROD6e2Ds3Ll8KDnmL6GNThSmfQqq\r\n5yMaXNZGYy/FK+MadWproExtDnOZrhji6Xdi2IblSJLXmBvirKO/X8uNqEpQ\r\nI5TOy0PhHv6l8gD/jtkt/4Va3+JIbCvlsK6Y43K1e15WPLBy0g4anY1qOpAK\r\nvO8HoN4gTmr3z1PXtC8xQpNJIQPsEBf8AQREYjvahYrU9KAayzPkusxo4YgG\r\nF7U52PIG13X9eRD699fCP1y13fyihlaua3emwJdy5F6U/uN3vKGcTUmrzXfc\r\nBKVQ2qOFea1nF9wjchHaanYzYypgqly811gRN005uFgB7A571lTF1BrA49kS\r\nWc0InIm8FYgv1aF5+L51B3Xa43J2IuABI9EZxskkf6+xs3m0YCw6hmBKUHx6\r\n+Tgj11ufi01nnlX5Anspv0OM3dZmXJOjFC7cdmWb6mCa4bNjqVP2o6YEqxG+\r\nPKBoueD2Ql5A6IyoEtCewTSLV82U90gTEnQ=\r\n=m9nw\r\n-----END PGP SIGNATURE-----\r\n"},"main":"dist/index.js","type":"module","types":"types/index.d.ts","unpkg":"dist/splaytree-ts.umd.js","module":"dist/index.js","exports":{"umd":"./dist/splaytree-ts.umd.js","default":"./dist/index.js"},"gitHead":"b2a66e68a18c29984ce668696c95027e38318ad2","scripts":{"test":"npm run test:typecheck && npm run test:lint","build":"rollup -c && tsc --declaration true --declarationDir types","test:lint":"eslint src","prepublishOnly":"npm run test && npm run build","test:typecheck":"tsc --noEmit"},"_npmUser":{"name":"sbanksx","email":"luiz.barboza2002@gmail.com"},"jsdelivr":"dist/splaytree-ts.umd.js","repository":{"url":"git+https://github.com/SBanksX/splaytree-ts.git","type":"git"},"_npmVersion":"8.15.0","description":"A splay tree typescript library","directories":{},"_nodeVersion":"18.7.0","_hasShrinkwrap":false,"devDependencies":{"eslint":"^8.16.0","@babel/preset-env":"^7.19.0","@rollup/plugin-json":"4","rollup-plugin-terser":"7","eslint-config-prettier":"^8.5.0","@babel/preset-typescript":"^7.18.6","@rollup/plugin-typescript":"^8.5.0","@typescript-eslint/parser":"^5.25.0","@rollup/plugin-node-resolve":"13","@typescript-eslint/eslint-plugin":"^5.25.0"},"_npmOperationalInternal":{"tmp":"tmp/splaytree-ts_1.0.1_1665692451344_0.6674600971209568","host":"s3://npm-registry-packages"}},"1.0.2":{"name":"splaytree-ts","description":"A splay tree typescript library","version":"1.0.2","author":{"name":"Luiz Felipe Machado Barboza"},"license":"BDS-3-Clause","type":"module","main":"dist/esm/index.js","module":"dist/esm/index.js","jsdelivr":"dist/splaytree-ts.umd.js","unpkg":"dist/splaytree-ts.umd.js","types":"dist/esm/index.d.ts","exports":{"umd":"./dist/splaytree-ts.umd.js","import":"./dist/esm/index.js","require":"./dist/cjs/index.cjs","default":"./dist/cjs/index.cjs"},"keywords":["splay","tree","map","set","self-balancing","binary","search"],"repository":{"type":"git","url":"git+https://github.com/SBanksX/splaytree-ts.git"},"scripts":{"preversion":"npm run test","version":"npm run build && git add -A","postversion":"git push && git push --tags","build":"rollup -c && tsup","test":"npm run test:typecheck && npm run test:lint","test:lint":"eslint src","test:typecheck":"tsc --noEmit"},"devDependencies":{"@typescript-eslint/eslint-plugin":"^5.25.0","@typescript-eslint/parser":"^5.25.0","@babel/preset-env":"^7.19.0","@babel/preset-typescript":"^7.18.6","@rollup/plugin-json":"4","@rollup/plugin-node-resolve":"13","@rollup/plugin-typescript":"^8.5.0","rollup-plugin-terser":"7","eslint":"^8.16.0","eslint-config-prettier":"^8.5.0","tsup":"^8.3.5"},"_id":"splaytree-ts@1.0.2","gitHead":"588a6017a6b4193ed7a7360ac117e779205d532a","bugs":{"url":"https://github.com/SBanksX/splaytree-ts/issues"},"homepage":"https://github.com/SBanksX/splaytree-ts#readme","_nodeVersion":"20.12.2","_npmVersion":"10.5.0","dist":{"integrity":"sha512-0kGecIZNIReCSiznK3uheYB8sbstLjCZLiwcQwbmLhgHJj2gz6OnSPkVzJQCMnmEz1BQ4gPK59ylhBoEWOhGNA==","shasum":"34963704587aff45eaa09c24713f552bbf56e8f0","tarball":"https://registry.npmjs.org/splaytree-ts/-/splaytree-ts-1.0.2.tgz","fileCount":11,"unpackedSize":169400,"signatures":[{"keyid":"SHA256:jl3bwswu80PjjokCgh0o2w5c2U4LhQAE57gj9cz1kzA","sig":"MEYCIQDGLnCMuAKBbFtmYoLzAC08vecG1hU+bxAyGFwgWZfwbwIhAMWg9uCaVIjO6O2PduyFNakfMFCpiljH+Af2FRg/Uvoz"}]},"_npmUser":{"name":"luizbarboza","email":"contact@luizbarboza.com"},"directories":{},"maintainers":[{"name":"luizbarboza","email":"contact@luizbarboza.com"}],"_npmOperationalInternal":{"host":"s3://npm-registry-packages-npm-production","tmp":"tmp/splaytree-ts_1.0.2_1733844708126_0.8772474044996246"},"_hasShrinkwrap":false}},"time":{"created":"2022-10-12T20:41:37.878Z","modified":"2024-12-10T15:31:48.457Z","1.0.0":"2022-10-12T20:41:38.011Z","1.0.1":"2022-10-13T20:20:51.574Z","1.0.2":"2024-12-10T15:31:48.301Z"},"bugs":{"url":"https://github.com/SBanksX/splaytree-ts/issues"},"author":{"name":"Luiz Felipe Machado Barboza"},"license":"BDS-3-Clause","homepage":"https://github.com/SBanksX/splaytree-ts#readme","keywords":["splay","tree","map","set","self-balancing","binary","search"],"repository":{"type":"git","url":"git+https://github.com/SBanksX/splaytree-ts.git"},"description":"A splay tree typescript library","maintainers":[{"name":"luizbarboza","email":"contact@luizbarboza.com"}],"readme":"# splaytree-ts\n\nA splay tree is a self-balancing binary search tree.\n\n```js\nconst ages = new SplayTreeSet();\nfor (let age of [33, 45, 25, 35, 59, 18, 62]) {\n  ages.add(age)\n}\nages.firstAfter(35);  // 45\nages.lastBefore(33);  // 25\nages.delete(59);      // true\nages.has(59);         // false\nages.firstAfter(45);  //  62\n```\n\nIt has the additional property that recently accessed elements are quick to access again.\nIt performs basic operations such as insertion, look-up and removal, in O(log(n)) amortized time.\n\n## API Reference\n\n* [SplayTreeMap](#splaytreemap)\n* [SplayTreeSet](#splaytreeset)\n\n### SplayTreeMap\n\nKeys of the map are compared using the compare function passed in the constructor, both for ordering and for equality. If the map contains only the key a, then map.has(b) will return true if and only if compare(a, b) == 0, and the value of a == b is not even checked. If the compare function is omitted, the objects are assumed to be comparable, and are compared in natural order. Non-comparable objects (including null) will not work as keys in that case.\n\nTo allow calling [*map*.get](#map_get), [*map*.delete](#map_delete) or [*map*.has](#map_has) with objects that are not supported by the compare function, an extra isValidKey predicate function can be supplied. This function is tested before using the compare function on an argument value that may not be a K value. If omitted, the isValidKey function defaults to testing if the value is neither null nor undefined.\n\nnew **SplayTreeMap**([*compare*(a, b)[, *isValidKey*(value)]])\n\n<a href=\"#map_clear\" name=\"map_clear\">#</a> *map*.**clear**()\n\nRemoves all pairs from the *map*.\n\nAfter this, the *map* is empty.\n\n<a href=\"#map_has\" name=\"map_has\">#</a> *map*.**has**(*key*)\n\nReturns true if the *map* contains the given *key*.\n\nReturns true if any of the keys in the *map* are equal to *key* according to the equality used by the *map*.\n\n<a href=\"#map_delete\" name=\"map_delete\">#</a> *map*.**delete**(*key*)\n\nRemoves *key* and its associated value, if present, from the *map*.\n\nReturns true if *map* contains the specified *key*, or false if *key* was not in the *map*.\n\n<a href=\"#map_forEach\" name=\"map_forEach\">#</a> *map*.**forEach**(*f*(*value*, *key*, *map*))\n\nApplies *f* to each *key*/*value* pair of the *map*.\n\nCalling *f* must not add or remove keys from the *map*.\n\n<a href=\"#map_get\" name=\"map_get\">#</a> *map*.**get**(*key*)\n\nReturns the value for the given *key* or undefined if *key* is not in the map.\n\nSome maps allow keys to have undefined as a value. For those maps, a lookup using this method cannot distinguish between a key not being in the map and the key having a undefined value. Methods like [*map*.hasValue](#map_hasValue) or [*map*.setIfAbsent](#map_setIfAbsent) can be used if the distinction is important.\n\n<a href=\"#map_hasValue\" name=\"map_hasValue\">#</a> *map*.**hasValue**(*value*)\n\nReturns true if the *map* contains the given *value*.\n\nReturns true if any of the values in the *map* are equal to *value* according to the == operator.\n\n<a href=\"#map_set\" name=\"map_set\">#</a> *map*.**set**(*key*, *value*)\n\nAssociates the *key* with the given *value*.\n\nIf the *key* was already in the *map*, its associated *value* is changed. Otherwise the key/value pair is added to the map.\n\n<a href=\"#map_setAll\" name=\"map_setAll\">#</a> *map*.**setAll**(*other*)\n\nAdds all key/value pairs of *other* to the map.\n\nIf a key of *other* is already in the *map*, its value is overwritten.\n\nThe operation is equivalent to doing [*map*.set](#map_set) for each key and associated value in *other*. It iterates over *other*, which must therefore not change during the iteration.\n\n<a href=\"#map_setIfAbsent\" name=\"map_setIfAbsent\">#</a> *map*.**setIfAbsent**(*key*, *ifAbsent*)\n\nLook up the value of *key*, or add a new value if it isn't there.\n\nReturns the value associated to *key*, if there is one. Otherwise calls *ifAbsent* to get a new value, associates *key* to that value, and then returns the new value.\n\n```js\nconst scores = new SplayTreeMap();\nscores.set('Bob', 36)\nfor (let key of ['Bob', 'Rohan', 'Sophena']) {\n  scores.setIfAbsent(key, () => key.length);\n}\nscores.get('Bob');      // 36\nscores.get('Rohan');    //  5\nscores.get('Sophena');  //  7\n```\n\nCalling *ifAbsent* must not add or remove keys from the *map*.\n\n<a href=\"#map_isEmpty\" name=\"map_isEmpty\">#</a> *map*.**isEmpty**()\n\nReturns true if there is no key/value pair in the *map*.\n\n<a href=\"#map_isNotEmpty\" name=\"map_isNotEmpty\">#</a> *map*.**isNotEmpty**()\n\nReturns true if there is at least one key/value pair in the *map*.\n\n<a href=\"#map_firstKey\" name=\"map_firstKey\">#</a> *map*.**firstKey**()\n\nGet the first key in the *map*. Returns null if the *map* is empty.\n\n<a href=\"#map_lastKey\" name=\"map_lastKey\">#</a> *map*.**lastKey**()\n\nGet the last key in the *map*. Returns null if the *map* is empty.\n\n<a href=\"#map_lastKeyBefore\" name=\"map_lastKeyBefore\">#</a> *map*.**lastKeyBefore**(*key*)\n\nGet the last key in the *map* that is strictly smaller than *key*. Returns null if no key was not found.\n\n<a href=\"#map_firstKeyAfter\" name=\"map_firstKeyAfter\">#</a> *map*.**firstKeyAfter**(*key*)\n\nGet the first key in the *map* that is strictly larger than *key*. Returns null if no key was not found.\n\n<a href=\"#map_update\" name=\"map_update\">#</a> *map*.**update**(*key*, *update*(*value*)[, *ifAbsent*])\n\nUpdates the *value* for the provided *key*.\n\nReturns the new value of the *key*.\n\nIf the *key* is present, invokes *update* with the current *value* and stores the new value in the *map*.\n\nIf the *key* is not present and *ifAbsent* is provided, calls *ifAbsent* and adds the *key* with the returned value to the *map*.\n\nIt's an error if the *key* is not present and *ifAbsent* is not provided.\n\n<a href=\"#map_updateAll\" name=\"map_updateAll\">#</a> *map*.**updateAll**(*update*(key, value))\n\nUpdates all values.\n\nIterates over all entries in the *map* and updates them with the result of invoking *update*.\n\n<a href=\"#map_keys\" name=\"map_keys\">#</a> *map*.**keys**()\n\nReturns an iterable of keys in the *map*.\n\nModifying the *map* while iterating the keys breaks the iteration.\n\n<a href=\"#map_values\" name=\"map_values\">#</a> *map*.**values**()\n\nReturns an iterable of values in the *map*.\n\nModifying the *map* while iterating the values breaks the iteration.\n\n<a href=\"#map_entries\" name=\"map_entries\">#</a> *map*.**entries**()\n\nReturns an iterable of key, value pairs for every entry in the *map*.\n\nModifying the *map* while iterating the entries breaks the iteration.\n\n### SplayTreeSet\n\nElements of the set are compared using the compare function passed in the constructor, both for ordering and for equality. If the set contains only an object a, then set.has(b) will return true if and only if compare(a, b) == 0, and the value of a == b is not even checked. If the compare function is omitted, the objects are assumed to be comparable, and are compared in natural order. Non-comparable objects (including null) will not work as keys in that case.\n\nnew **SplayTreeSet**([*compare*(a, b)[, *isValidKey*(value)]])\n\n<a href=\"#set_clear\" name=\"set_clear\">#</a> *set*.**clear**()\n\nRemoves all elements in the *set*.\n\n<a href=\"#set_has\" name=\"set_has\">#</a> *set*.**has**(*element*)\n\nReturns true if the *set* contains an element equal to *element*.\n\n<a href=\"#set_delete\" name=\"set_delete\">#</a> *set*.**delete**(*element*)\n\nRemoves *element* from the *set*. Returns true if *element* was in the *set*. Returns false otherwise. The method has no effect if *element* was not in the *set*.\n\n<a href=\"#set_deleteAll\" name=\"set_deleteAll\">#</a> *set*.**deleteAll**(*elements*)\n\nRemoves each element of *elements* from the *set*.\n\n<a href=\"#set_forEach\" name=\"set_forEach\">#</a> *set*.**forEach**(*f*(*element*, element2, *set*))\n\nApplies the function *f* to each *element* of the *set* in iteration order.\n\n<a href=\"#set_add\" name=\"set_add\">#</a> *set*.**add**(*element*)\n\nAdds the *element* to the *set* if it is not already in the *set*.\n\nReturns the *set*.\n\n<a href=\"#set_addAndreturn\" name=\"set_addAndreturn\">#</a> *set*.**addAndReturn**(*element*)\n\nAdds the *element* to the *set* if it is not already in the *set*.\n\nReturns the *element* (or an equal element if there is already one in the *set*).\n\n<a href=\"#set_addAll\" name=\"set_addAll\">#</a> *set*.**addAll**(*elements*)\n\nAdds all *elements* to the *set*.\n\nEquivalent to adding each element in *elements* using [*set*.add](#set_add).\n\n<a href=\"#set_isEmpty\" name=\"set_isEmpty\">#</a> *set*.**isEmpty**()\n\nReturns true if there are no elements in the *set*.\n\nMay be computed by checking if iterator.next().done == true\n\n<a href=\"#set_isNotEmpty\" name=\"set_isNotEmpty\">#</a> *set*.**isNotEmpty**()\n\nReturns true if there is at least one element in the *set*.\n\nMay be computed by checking if iterator.next().done == false\n\n<a href=\"#set_single\" name=\"set_single\">#</a> *set*.**single**()\n\nChecks that the *set* has only one element, and returns that element.\n\nThrows a StateError if the *set* is empty or has more than one element.\n\n<a href=\"#set_first\" name=\"set_first\">#</a> *set*.**first**()\n\nReturns the first element.\n\nThrows a StateError if the *set* is empty. Otherwise returns the first element in the iteration order.\n\n<a href=\"#set_last\" name=\"set_last\">#</a> *set*.**last**()\n\nReturns the last element.\n\nThrows a StateError if the *set* is empty. Otherwise may iterate through the elements and returns the last one seen.\n\n<a href=\"#set_lastBefore\" name=\"set_lastBefore\">#</a> *set*.**lastBefore**(*element*)\n\nGet the last element in the *set* that is strictly smaller than *element*. Returns null if no element was not found.\n\n<a href=\"#set_firstAfter\" name=\"set_firstAfter\">#</a> *set*.**firstAfter**(*element*)\n\nGet the first element in the *set* that is strictly larger than *element*. Returns null if no element was not found.\n\n<a href=\"#set_retainAll\" name=\"set_retainAll\">#</a> *set*.**retainAll**(*elements*)\n\nRemoves all elements of the *set* that are not elements in *elements*.\n\nChecks for each element of *elements* whether there is an element in thes *set* that is equal to it (according to [*set*.has](#set_has)), and if so, the equal element in thes *set* is retained, and elements that are not equal to any element in *elements* are removed.\n\n<a href=\"#set_lookup\" name=\"set_lookup\">#</a> *set*.**lookup**(*object*)\n\nIf an object equal to *object* is in the *set*, return it.\n\nChecks whether *object* is in the *set*, like [*set*.has](#set_has), and if so, returns the *object* in the *set*, otherwise returns null.\n\nIf the equality relation used by the *set* is not identity, then the returned object may not be identical to *object*.\n\n<a href=\"#set_intersection\" name=\"set_intersection\">#</a> *set*.**intersection**(*other*)\n\nReturns a new set which is the intersection between thes *set* and *other*.\n\nThat is, the returned set contains all the elements of the *set* that are also elements of *other* according to [*set*.has](#set_has).\n\n<a href=\"#set_difference\" name=\"set_difference\">#</a> *set*.**difference**(*other*)\n\nReturns a new set with the elements of the *set* that are not in *other*.\n\nThat is, the returned set contains all the elements of the *set* that are not elements of *other* according to [*set*.has](#set_has).\n\n<a href=\"#set_union\" name=\"set_union\">#</a> *set*.**union**(*other*)\n\nReturns a new set which contains all the elements of the *set* and *other*.\n\nThat is, the returned set contains all the elements of the *set* and all the elements of *other*.\n\n<a href=\"#set_toSet\" name=\"set_toSet\">#</a> *set*.**toSet**()\n\nCreates a set containing the same elements as the *set*.\n\n<a href=\"#set_keys\" name=\"set_keys\">#</a> *set*.**keys**()\n\nDespite its name, returns an iterable of the values in the *set*.\n\nModifying the *set* while iterating the values breaks the iteration.\n\n<a href=\"#set_values\" name=\"set_values\">#</a> *set*.**values**()\n\nReturns an iterable of values in the *set*.\n\nModifying the *set* while iterating the values breaks the iteration.\n\n<a href=\"#set_entries\" name=\"set_entries\">#</a> *set*.**entries**()\n\nReturns an iterable of [v,v] pairs for every value v in the *set*.\n\nModifying the *set* while iterating the entries breaks the iteration.\n","readmeFilename":"README.md"}